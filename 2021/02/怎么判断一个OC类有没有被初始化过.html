<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 怎么判断一个OC类有没有被初始化过 · 苹果梨的博客</title><meta name="description" content="怎么判断一个OC类有没有被初始化过 - 苹果梨"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://blog.harrisonxi.com/atom.xml" title="苹果梨的博客"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about.html" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/links.html" target="_self" class="nav-list-link">友链</a></li><li class="nav-list-item"><a href="https://github.com/HarrisonXi" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">怎么判断一个OC类有没有被初始化过</h1><div class="post-subtitle">阅读解析并应用runtime源码</div><div class="post-info">2021-02-22<a href="/categories/ObjC" class="post-category">ObjC</a></div><div class="post-content"><p>随着app size的日渐增加，大家都可能会有裁剪app size的需要。当然整块的砍掉使用率低的功能模块是最彻底也最简单的，但这会因为面临各种压力而难以执行……那么主要采用的就是一些常用技术方案：压缩图片、资源后下发、优化代码还有二进制重排列等。</p>
<p>还有一个重要的方向，就是删除无用的代码。不过这个方向在技术上还是有些难度的，因为OC这门语言的特殊性，很难使用静态检查的方法找出无用代码。那么就要借助在运行时实时分析的方案来做，分析的粒度大小主要分为函数粒度和类粒度。按照函数的粒度来分析，要么是在runtime里hook <code>msg_send</code>相关的入口，这样做对性能的影响蛮大；要么是深入了解底层原理后，在编译期做好插桩工作，这样做需要对相应底层技术有十分深入的理解。总之，要么很废，要么很难。所以我们这次利用runtime自带的特性，从类的粒度来分析一下类有没有被初始化过即可。</p>
<a id="more"></a>

<h1 id="大致方案"><a href="#大致方案" class="headerlink" title="大致方案"></a>大致方案</h1><p>很多技术博客里都提到了，ObjC类的meta class里，自带了一个标记自己有没有初始化过的flag。但是这些文章大部分都是点到为止，没有更深入的介绍具体的实践方法，今天我在这里就整理并提供一个可以实践的方案。</p>
<p>我们要做的就是利用runtime扫描一遍所有ObjC类的列表，然后再定期扫描这列表里所有的类有没有初始化过，获得大量数据后再进行分析，就可以得到初始化次数最少甚至为零的类啦。</p>
<p>听上去挺简单，但是具体有什么难点要实践了才知道，那就开始吧。</p>
<p>当然如果你不想看下面的长篇大论，可以直接看已经放在GitHub的开源库：<a href="https://github.com/HarrisonXi/SLMClassCoverage" target="_blank" rel="noopener">SLMClassCoverage</a></p>
<h1 id="扫描ObjC类的列表"><a href="#扫描ObjC类的列表" class="headerlink" title="扫描ObjC类的列表"></a>扫描ObjC类的列表</h1><p>扫描所有的ObjC类其实挺简单的，一句<a href="https://developer.apple.com/documentation/objectivec/1418762-objc_copyclasslist?language=objc" target="_blank" rel="noopener">objc_copyClassList</a>就搞定了。但是扫描完立刻就发现了问题，一个几乎空白的demo工程，系统类的数量就已经成千上万了。</p>
<p>找了找思路，发现可以用<code>[NSBundle bundleForClass:XXXClass]</code>是不是<code>[NSBundle mainBundle]</code>来判断一个类是不是主bundle里的类。经过了一番尝试，方案可行是可行，但是又发现了新的问题，这个NSBundle是线程不安全的。扫描大量的类是个耗时操作，直接扔在主线程来做可不好。</p>
<p>好在有了思路就不难办，仔细想想runtime的<a href="https://developer.apple.com/documentation/objectivec/1418539-class_getimagename?language=objc" target="_blank" rel="noopener">class_getImageName</a>也可以完成类似的效果，记录下主bundle对应的image再进行比对就可以了，实验了下效果也很不错。</p>
<p>整理完app内用户自有类列表之后，梳理数据的时候又发现一个小问题。因为ObjC这个语言是动态的，可以在运行时动态添加类，一些observer操作还有RAC操作容易产生一些动态类成为干扰数据，这就有点难办了。有一些这样的类的类名是下划线开头的，我就顺手把这些类给屏蔽了；其它一些难以判断的，就只能加一些保护防止崩溃了。（如果有什么好的idea欢迎讨论）</p>
<p>至此，我们把要扫描的类列表就能整理出来了，详细的代码可以参照上面的源代码。</p>
<h1 id="判断类有没有被初始化过"><a href="#判断类有没有被初始化过" class="headerlink" title="判断类有没有被初始化过"></a>判断类有没有被初始化过</h1><p>ObjC runtime的开源代码真的是一个好东西，因为C系列语言指针的自由度，了解runtime的结构后基本上可以完成各种各样的骚操作。咳咳，当然骚操作不建议瞎用，除非你真的把它搞明白了，因为有时候骚操作会带来很可怕的副作用。</p>
<p>ObjC 类的结构主要是在<code>objc-runtime-new.h</code>这个文件里定义的，下面是这个文件最新两版开源代码的地址：<a href="https://opensource.apple.com/source/objc4/objc4-787.1/runtime/objc-runtime-new.h.auto.html" target="_blank" rel="noopener">objc4-787.1</a>，<a href="https://opensource.apple.com/source/objc4/objc4-818.2/runtime/objc-runtime-new.h.auto.html" target="_blank" rel="noopener">objc4-818.2</a></p>
<p>以后面这个最新版为例，先打开文件，找到下面的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc_class 代码片段</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>objc_class</code>的<code>isInitialized</code>就是我们要用到的方法了。但是很可惜，这些方法对我们app来说，都是不可见的。所以在这里我教一下大家，怎么分析出我们要用到的变量的偏移地址，直接用指针来搞定问题。</p>
<p>从方法的调用情况看到我们要先找到类的meta class，这个是个runtime里可见的方法，直接调用就能拿到。然后回到<code>objc_class</code>的头部几行：</p>
<p><img src="/2021/02/22-170300.png" alt="22-170300"></p>
<p><strong>⚠️ 注意：为了简化我们的问题，我们只考虑64位架构处理器的情况。</strong>毕竟iOS在11.0以后就木有支持32位的CPU了，多研究也没有很大价值。</p>
<p>从之前那段<code>objc_class 代码片段</code>可以看出来，<code>objc_class-&gt;data()</code>方法取到的就是头部定义的这个<code>bits</code>变量里的<code>data()</code>，我们最终要找的就是怎么拿到这个值，也就是先要找到上面截图里横线上这个成员变量<code>bits</code>的内存偏移地址。</p>
<p>runtime源代码是用C++来写的，函数都不会占用类meta信息（或者说实例）的内存地址，只有成员变量会占用地址。什么意思呢？看下面的图：</p>
<p><img src="/2021/02/22-171509.png" alt="22-171509"></p>
<p>这个就是<code>objc_class</code>的父结构体，具体代码在<a href="https://opensource.apple.com/source/objc4/objc4-818.2/runtime/objc-private.h.auto.html" target="_blank" rel="noopener">objc-private.h</a>里。以这个结构体为例，<code>isa</code>这个成员变量会占用类实例的头8个bytes，也就是64位CPU的一个指针的长度；而下面的这堆方法，在实例里面一点内存都不占用。然后看完整个结构体，只有这么一个成员变量，所以总长度也就8个bytes。</p>
<p><img src="/2021/02/23-111407.png" alt="23-111407"></p>
<p>回到这张图里，对于子结构体来说，是需要继承父结构体的成员变量的。所以<code>objc_class</code>在继承<code>objc_object</code>时，就带上了父结构体的8 bytes长度的<code>isa</code>指针变量。</p>
<p><code>objc_class</code>内前面几行那几个函数禁用语句，不会产生内存地址的偏移，先不管它们。</p>
<p><code>superclass</code>作为一个指针（对，<code>Class</code>类型实际上是一个指向结构体的指针），长度也是8 bytes。</p>
<p>然后我们发现一个不太认识的<code>cache_t</code>类型的变量<code>cache</code>，它占用了多少bytes我们就要展开看看了：</p>
<p><img src="/2021/02/18-172136.png" alt="18-172136"></p>
<p>首先说一下<code>explicit_atomic&lt;T&gt;</code>，它只是负责把模板里的类型包成atomic的，不会对变量占用的内存长度产生影响。</p>
<p>然后要说一下<code>union</code>，C++的老朋友了，联合体内部的成员取最长的一个内存长度，就是联合体的内存长度。</p>
<p><code>mask_t</code>的定义在文件头就能找到，其实在64位CPU下就是一个<code>uint32_t</code>而已。</p>
<p>基于上面的介绍，可以推断出整个<code>cache_t</code>结构体的长度就是16 bytes（详情参照上图标记）。最后得到：</p>
<p><img src="/2021/02/18-172720.png" alt="18-172720"></p>
<p>接下来就是要分析<code>bits.data()-&gt;flag</code>的位置了，很凑巧的是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flag 取法代码片段</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> objc_class;</span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bits</code>和<code>flags</code>都是两个结构体里的第一个成员变量，那么我们就不需要继续计算偏移了，留意下<code>data()</code>函数的具体取值方法即可。</p>
<p>最终我们从一个Class类型，取到它有没有被初始化过的代码大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class metaCls = objc_getMetaClass(class_getName(cls));</span><br><span class="line"><span class="keyword">if</span> (metaCls) &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> *bits = (__bridge <span class="keyword">void</span> *)metaCls + <span class="number">32</span>; <span class="comment">// 在 metaClass 基地址上加上 32 bits 的偏移</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *data = (<span class="keyword">uint32_t</span> *)(*bits &amp; FAST_DATA_MASK); <span class="comment">// 模拟 data() 函数取值</span></span><br><span class="line">    <span class="keyword">return</span> (*data &amp; RW_INITIALIZED); <span class="comment">// 模拟 isInitialized() 函数最后一步与操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NO;</span><br></pre></td></tr></table></figure>

<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>这个<code>isInitialized</code>的取法完成了，但是它只是数据收集开始的第一步。</p>
<p>扫描类有没有被初始化过是个很快的操作，但是扫描出整个类列表的过程很慢，主要是<code>class_getImageName</code>很慢，所以我在开源库里做了一些简单的缓存策略。这点需要大家自己留意下，根据自己的需要自行修改。</p>
<p>后面基于不同项目的情况和需要，大家还得自己设计数据上传及分析的流程。</p>
<p>希望这篇文章对大家有帮助吧，今天就写到这里。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2022/01/2021%E6%80%BB%E7%BB%93.html" class="prev">上一篇</a><a href="/2020/10/%E6%97%B6%E9%9A%94%E4%B8%A4%E5%B9%B4CoreTelephony%E5%BA%93%E5%8F%88%E5%9D%91%E4%BA%86.html" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'ping-guo-li-de-bo-ke';
var disqus_identifier = '2021/02/怎么判断一个OC类有没有被初始化过.html';
var disqus_title = '怎么判断一个OC类有没有被初始化过';
var disqus_url = 'https://blog.harrisonxi.com/2021/02/怎么判断一个OC类有没有被初始化过.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//ping-guo-li-de-bo-ke.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2024 <a href="https://blog.harrisonxi.com">苹果梨</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-110376743-1",'auto');ga('send','pageview');</script></body></html>