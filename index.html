<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 苹果梨的博客</title><meta name="description" content="苹果梨的iOS/ObjC技术博客"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://blog.harrisonxi.com/atom.xml" title="苹果梨的博客"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about.html" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/links.html" target="_self" class="nav-list-link">友链</a></li><li class="nav-list-item"><a href="https://github.com/HarrisonXi" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2024/02/%E9%9C%80%E6%B1%82%E7%9A%84%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%20vs%20%E4%BB%A3%E7%A0%81%E7%9A%84%E9%95%BF%E6%9C%9F%E7%BB%B4%E6%8A%A4.html" class="post-title-link">需求的快速实现 vs 代码的长期维护</a></h2><div class="post-subtitle">程序员的两大类工作</div><div class="post-info">2024-02-06<a href="/categories/iOS" class="post-category">iOS</a></div><div class="post-content"><p>对不起，稍微有点标题党。下面先酝酿下正题。</p>
<p>随着做程序员的时间越来越久，经历过快速跑业务堆需求，经历过做基础做框架搞平台搞提效，越来越觉得代码的可维护性不是个非好即坏的状态。有复杂的各种输入影响代码的最终状态（指可维护性、后略），代码的状态又进一步影响项目，最终在当前项目这个整个大的研发系统下达到一定的平衡。这个平衡状态可能不是大家想要的状态，但是一般这种平衡却其实是较符合项目现状的稳定状态。如果没有较大的外力来影响系统，这个平衡是比较难打破和改变的。只要不出现项目无法维护的情况，那它有可能会一直持续下去。</p>
<p>今天我想就这一些状态、影响和平衡，过去这些年产生的技术、框架解决的一些问题等，聊聊我的思考。</p></div><a href="/2024/02/%E9%9C%80%E6%B1%82%E7%9A%84%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%20vs%20%E4%BB%A3%E7%A0%81%E7%9A%84%E9%95%BF%E6%9C%9F%E7%BB%B4%E6%8A%A4.html" class="read-more">阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2022/01/2022%E6%80%BB%E7%BB%93.html" class="post-title-link">2022总结</a></h2><div class="post-info">2022-01-22<a href="/categories/%E9%9A%8F%E7%AC%94" class="post-category">随笔</a></div><div class="post-content"><p>沉寂了一年的博客又来诈尸了。</p>
<p>这一年一如既往的很多不如意，时间依然不足，也依然没有回本。</p></div><a href="/2022/01/2022%E6%80%BB%E7%BB%93.html" class="read-more">阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2022/01/2021%E6%80%BB%E7%BB%93.html" class="post-title-link">2021总结</a></h2><div class="post-info">2022-01-04<a href="/categories/%E9%9A%8F%E7%AC%94" class="post-category">随笔</a></div><div class="post-content"><p>2021年过去得很快，成年人的生活就是如此千篇一律，让人感觉时光飞逝。其实我个人已经不喜欢这种节奏了，留给自己的自由时间还是太少了。不过上班总归还是要上的，毕竟……</p>
<p>这一年失去了很多，感慨下终归还是没有办法调节好生活中所有的平衡。当然也和大部分中概人一样：</p>
<p><img src="/2022/01/01.jpg" alt="01"></p>
<p>不过这一年也学会了很多，有所付出终归有所收获。时间越来越不够用，原定的计划做了不少调整，不过总体来说还可以接受。</p></div><a href="/2022/01/2021%E6%80%BB%E7%BB%93.html" class="read-more">阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2021/02/%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AAOC%E7%B1%BB%E6%9C%89%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87.html" class="post-title-link">怎么判断一个OC类有没有被初始化过</a></h2><div class="post-subtitle">阅读解析并应用runtime源码</div><div class="post-info">2021-02-22<a href="/categories/ObjC" class="post-category">ObjC</a></div><div class="post-content"><p>随着app size的日渐增加，大家都可能会有裁剪app size的需要。当然整块的砍掉使用率低的功能模块是最彻底也最简单的，但这会因为面临各种压力而难以执行……那么主要采用的就是一些常用技术方案：压缩图片、资源后下发、优化代码还有二进制重排列等。</p>
<p>还有一个重要的方向，就是删除无用的代码。不过这个方向在技术上还是有些难度的，因为OC这门语言的特殊性，很难使用静态检查的方法找出无用代码。那么就要借助在运行时实时分析的方案来做，分析的粒度大小主要分为函数粒度和类粒度。按照函数的粒度来分析，要么是在runtime里hook <code>msg_send</code>相关的入口，这样做对性能的影响蛮大；要么是深入了解底层原理后，在编译期做好插桩工作，这样做需要对相应底层技术有十分深入的理解。总之，要么很废，要么很难。所以我们这次利用runtime自带的特性，从类的粒度来分析一下类有没有被初始化过即可。</p></div><a href="/2021/02/%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AAOC%E7%B1%BB%E6%9C%89%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87.html" class="read-more">阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/10/%E6%97%B6%E9%9A%94%E4%B8%A4%E5%B9%B4CoreTelephony%E5%BA%93%E5%8F%88%E5%9D%91%E4%BA%86.html" class="post-title-link">时隔两年CoreTelephony库又坑了</a></h2><div class="post-subtitle">那些标错了available版本的系统API</div><div class="post-info">2020-10-30<a href="/categories/iOS" class="post-category">iOS</a></div><div class="post-content"><p>时隔两年苹果又坑了，还是那个熟悉的CoreTelephony库，还是那个熟悉的<code>CTTelephonyNetworkInfo.h</code>，还是那个熟悉的available标错导致的崩溃。</p></div><a href="/2020/10/%E6%97%B6%E9%9A%94%E4%B8%A4%E5%B9%B4CoreTelephony%E5%BA%93%E5%8F%88%E5%9D%91%E4%BA%86.html" class="read-more">阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/04/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E5%92%8C%E9%80%89%E5%9E%8B%E4%B8%AD%E7%9A%84%E6%80%9D%E8%80%83.html" class="post-title-link">方案设计和选型中的思考</a></h2><div class="post-info">2020-04-02<a href="/categories/%E5%85%B6%E5%AE%83" class="post-category">其它</a></div><div class="post-content"><p>之前聊的一些内容都倾向于某个方向，不够普遍适用。所以今天就聊一聊在技术生涯中的一些经验和思路，可以应用在各种方案设计和选型中。</p>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>无论做什么事情，都是始于学习的。技术这个行业更是要求很强的学习能力，每天都在更新各种各样的新技术，每一项技术也都可以研究得很深入。</p></div><a href="/2020/04/%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E5%92%8C%E9%80%89%E5%9E%8B%E4%B8%AD%E7%9A%84%E6%80%9D%E8%80%83.html" class="read-more">阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8%E8%AF%BE%EF%BC%9A%EF%BC%88%E4%BA%94%EF%BC%89%E8%A7%A3%E6%9E%90ID%E5%9E%8B%E8%AF%8D%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%AF%AD%E6%B3%95.html" class="post-title-link">编译原理入门课：（五）解析ID型词法和函数调用语法</a></h2><div class="post-info">2019-07-11<a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86" class="post-category">编译原理</a></div><div class="post-content"><p>上一章词法分析的内容里我们介绍了解析数字的方法，当时还提到了对ID的解析，但是因为当时还用不到ID类型，所以就没有做对应的解析，这一章我们将会讲解下ID类型的解析方法。</p>
<p>ID类型通常用在变量名和函数名上，变量要应用的话至少还得实现赋值表达式，所以我们先用ID类型来尝试实现函数调用功能。注意是调用我们在计算器里内置的函数，暂时还没有办法动态定义新的函数。</p></div><a href="/2019/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8%E8%AF%BE%EF%BC%9A%EF%BC%88%E4%BA%94%EF%BC%89%E8%A7%A3%E6%9E%90ID%E5%9E%8B%E8%AF%8D%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%AF%AD%E6%B3%95.html" class="read-more">阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8%E8%AF%BE%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E7%94%A8%E8%AF%8D%E6%B3%95%E8%A7%A3%E6%9E%90%E5%A4%84%E7%90%86%E5%A4%9A%E4%BD%8D%E6%95%B0%E5%AD%97%E5%92%8C%E7%A9%BA%E7%99%BD%E7%AC%A6.html" class="post-title-link">编译原理入门课：（四）用词法解析处理多位数字和空白符</a></h2><div class="post-info">2019-07-10<a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86" class="post-category">编译原理</a></div><div class="post-content"><p>之前为了快速进入主题，我们约定了表达式里只会出现个位数的数字。现在是时候打破这个规则，支持多位数的数字了。为了支持这点，我们就需要接触一个新的步骤——词法分析。</p>
<h1 id="词法分析的作用"><a href="#词法分析的作用" class="headerlink" title="词法分析的作用"></a>词法分析的作用</h1><p>词法分析就是把一个完整的语句拆分成一个个词（token），方便之后进行进一步的语法分析。</p>
<p>举个简单的例子：<code>今天真热</code>，将会被拆分成<code>&lt;今天&gt;, &lt;真&gt;, &lt;热&gt;</code>。当然拆分成<code>&lt;今&gt;, &lt;天真&gt;, &lt;热&gt;</code>也是一种可能，但是这样的分词方式不符合汉语的语法。</p></div><a href="/2019/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8%E8%AF%BE%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E7%94%A8%E8%AF%8D%E6%B3%95%E8%A7%A3%E6%9E%90%E5%A4%84%E7%90%86%E5%A4%9A%E4%BD%8D%E6%95%B0%E5%AD%97%E5%92%8C%E7%A9%BA%E7%99%BD%E7%AC%A6.html" class="read-more">阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8%E8%AF%BE%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89%E7%AE%80%E5%8D%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91%E4%BB%A5%E5%8F%8A%E8%B4%9F%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%90.html" class="post-title-link">编译原理入门课：（三）简单错误处理逻辑以及负数的解析</a></h2><div class="post-info">2019-07-05<a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86" class="post-category">编译原理</a></div><div class="post-content"><p>我们的解析器已经可以处理基本的加减乘除运算并支持括号了。但是随着功能越来越多，可能出现的错误也越来越多。不重视错误处理的话，碰到非法的表达式时会出现什么结果，我们完全是无法预料的。所以本章就打个岔，给解析器加上一套错误处理逻辑。这知识和编译原理关系不大，不感兴趣的朋友可以略过。</p>
<p>本章还会顺带聊一聊负数的解析，用递归的方式处理负数可以做的很简单，想复杂点也可以做的很复杂。如果是用<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">调度场算法</a>处理表达式中的负数的话，推荐看看<a href="https://cp-algorithms.com/string/expression_parsing.html" target="_blank" rel="noopener">这一篇文章（英文）</a>，我就不深入分析了。负数解析不涉及到编译原理相关的新知识，不感兴趣也可以略过。</p></div><a href="/2019/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8%E8%AF%BE%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89%E7%AE%80%E5%8D%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91%E4%BB%A5%E5%8F%8A%E8%B4%9F%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%90.html" class="read-more">阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8%E8%AF%BE%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%92%E5%BD%92%E8%A7%A3%E6%9E%90%E4%B8%AD%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.html" class="post-title-link">编译原理入门课：（二）递归解析中怎么处理运算符优先级</a></h2><div class="post-info">2019-07-04<a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86" class="post-category">编译原理</a></div><div class="post-content"><p>今天要给我们的“计算器”加上乘、除和取模三种运算，并且加上对括号的优先级处理。</p>
<p>如果不是采用递归方式解析表达式的话，可以参考下<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">调度场算法</a>，这是一个利用队列和堆栈来解决计算优先级的经典算法。</p>
<p>用递归方式解析的话，只要深刻理解了上一章的知识，这一章的都是小意思，那么我们开始。</p></div><a href="/2019/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8%E8%AF%BE%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%92%E5%BD%92%E8%A7%A3%E6%9E%90%E4%B8%AD%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.html" class="read-more">阅读全文</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">下一页</a></div><div class="copyright"><p>© 2017 - 2024 <a href="https://blog.harrisonxi.com">苹果梨</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-110376743-1",'auto');ga('send','pageview');</script></body></html>