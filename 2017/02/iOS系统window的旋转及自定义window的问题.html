<!DOCTYPE html>
<html>
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Mac OS X version 5.4.0">
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width initial-scale=1'>
  <title>苹果梨的博客 - iOS系统window的旋转及自定义window的问题</title>
  <link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&amp;subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  <link href='/css/github.css' rel='stylesheet' type='text/css'>
  <link href='/css/myblog.css' rel='stylesheet' type='text/css'>
</head>
<body class='typora-export'>
  <div id='write' class='is-mac'>
    <h1><a name='header-c315' class='md-header-anchor' id="header-c315"></a>iOS系统window的旋转及自定义window的问题</h1>
    <h3><a name='header-c316' class='md-header-anchor' id="header-c316"></a>玩转window，真的是玩『转』</h3>
    <table>
      <thead>
        <tr>
          <th>更新时间</th>
          <th>更新内容</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>2017-02-15</td>
          <td>发布</td>
        </tr>
      </tbody>
    </table>
    <p>具体某些细节内容和我的开源库<a href='https://github.com/HarrisonXi/TopmostView'>TopmostView</a>相关。</p>
    <p>大家的App都会有全屏的引导页或者Loading界面之类吧？如果你的App结构比较简单，比如RootController是一个NavigationController，而且需要展示全屏页面的时候不存在present新VC或正在做VC切换动画之类的情况，那么直接在RootController的view上面做这些就可以。但是因为这种方案下还有各种意想不到的情况会导致全屏页面展示出问题，所以大家一般又会选择在application window上加一个subview来处理全屏页面的展示。</p>
    <p>在App不存在旋转的情况下，这个方法就是最终最优解了。</p>
    <p>在App支持旋转的情况下，要处理的问题就比较多了，下面整理我遇到的一些问题。</p>
    <h4><a name='header-c332' class='md-header-anchor' id="header-c332"></a>iOS7的window和之后版本iOS系统的表现不一致</h4>
    <p>在一个iOS7的iPad上创建一个自定义window，再呼起键盘确保键盘window出现，在横屏的状态下断点并打印一下所有window的列表（过滤了一些我们不需要的信息）：</p>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;__NSArrayM 0x165c5d20&gt;(
&lt;UIWindow: 0x1656e710; frame = (0 0; 768 1024)&gt;,
&lt;UITextEffectsWindow: 0x165bcdc0; frame = (0 0; 768 1024); transform = [0, 1, -1, 0, -128, 128]&gt;,
&lt;UIWindow: 0x1659bc70; frame = (0 0; 768 1024); userInteractionEnabled = NO&gt;,
)</pre>
    <p>可以看到两点：</p>
    <ul>
      <li>window的宽高始终固定是768x1024，即竖屏的状态</li>
      <li>键盘window自带了一个transform属性，正好可以将竖屏的window旋转成横屏的大小&amp;位置</li>
    </ul>
    <p>键盘window是iOS7里，系统唯一自动处理了的window，因此维持其subview在横屏的时候frame = (0 0; 1024 768)，竖屏的时候frame = (0 0; 768 1024)就可以保证展示正常。</p>
    <p>而其它window的frame和transform都没有被处理，系统是怎么保证我们的界面显示正常呢？打印application window的subview看一下就明白了（过滤了一些我们不需要的信息）：</p>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;__NSArrayM 0x165c09f0&gt;(
&lt;UILayoutContainerView: 0x16570400; frame = (0 0; 768 1024); transform = [0, 1, -1, 0, 0, 0]; autoresize = W+H;&gt;
)</pre>
    <p>原来系统是处理了window的subview，给它加上了一个transform。所以在iOS7下面给键盘window外其它window加subview的时候，需要在设备旋转的时候处理一下subview的transform属性，保持和系统管理的那个subview一致。</p>
    <h4><a name='header-c352' class='md-header-anchor' id="header-c352"></a>iOS8-10的window</h4>
    <p>先拿个iOS8的iPhone做类似的实验（过滤了一些我们不需要的信息）：</p>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;__NSArrayM 0x78977ab0&gt;(
&lt;UIWindow: 0x7889e8e0; frame = (0 0; 568 320)&gt;,
&lt;UITextEffectsWindow: 0x788ae8c0; frame = (0 0; 568 320); autoresize = W+H&gt;,
&lt;UIWindow: 0x788d9fa0; frame = (0 0; 568 320); userInteractionEnabled = NO&gt;
)</pre>
    <p>可以看到横屏的时候，系统为window维护了正确的宽高，即使我并没有给自定义window增加autoresize = W+H的属性。</p>
    <p>顺带看一下application window的subview是什么样子的（过滤了一些我们不需要的信息）：</p>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>&lt;__NSArrayM 0x788aeb90&gt;(
&lt;UILayoutContainerView: 0x7863bdc0; frame = (0 0; 568 320); autoresize = W+H&gt;
)</pre>
    <p>系统管理的view加了autoresize = W+H属性，应该就是利用这个保证了横竖屏旋转时subview的尺寸正确。</p>
    <p>在iOS9/10的表现基本一致，总体来说我们要做的就是在设备旋转时保证我们自己添加的subview尺寸正确。</p>
    <h4><a name='header-c365' class='md-header-anchor' id="header-c365"></a>设备旋转事件的系统通知</h4>
    <p>在iOS中，设备方向相关的定义都是叫做StatusBarOrientation，下面列出一些常用的定义：</p>
    <pre class="md-fences md-end-block" lang="objective-c"> </pre>
    <div class="CodeMirror cm-s-inner CodeMirror-wrap">
      <div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"></div>
      <div class="CodeMirror-hscrollbar" style="left: 0px; min-height: 18px;">
        <div style="height: 100%; min-height: 1px; width: 0px;"></div>
      </div>
      <div class="CodeMirror-vscrollbar" style="min-width: 18px;">
        <div style="min-width: 1px; height: 0px;"></div>
      </div>
      <div class="CodeMirror-scrollbar-filler"></div>
      <div class="CodeMirror-gutter-filler"></div>
      <div class="CodeMirror-scroll" tabindex="-1">
        <div class="CodeMirror-sizer" style="margin-left: 0px; min-height: 0px;">
          <div style="position: relative; top: 0px;">
            <div class="CodeMirror-lines">
              <div style="position: relative; outline: none;">
                <div class="CodeMirror-measure">
                  <div style="width: 50px; height: 50px; overflow-x: scroll;"></div>
                </div>
                <div class="CodeMirror-measure"></div>
                <div style="position: relative; z-index: 1;"></div>
                <div class="CodeMirror-code" style="">
                  <div class="CodeMirror-activeline" style="position: relative;">
                    <div class="CodeMirror-activeline-background CodeMirror-linebackground"></div>
                    <pre class=""><span style="padding-right: 0.1px;"><span class="cm-comment">// 取得当前的设备方向</span></span></pre>
                  </div>
                  <pre class=""><span style="padding-right: 0.1px;">[<span class="cm-variable">UIApplication</span> <span class="cm-variable">sharedApplication</span>].<span class="cm-variable">statusBarOrientation</span></span></pre>
                  <pre class=""><span style="padding-right: 0.1px;"><span class="cm-comment">// 设备即将改变方向的通知事件name</span></span></pre>
                  <pre class=""><span style="padding-right: 0.1px;"><span class="cm-variable">UIApplicationWillChangeStatusBarOrientationNotification</span></span></pre>
                  <pre class=""><span style="padding-right: 0.1px;"><span class="cm-comment">// 设备已经改变方向的通知事件name</span></span></pre>
                  <pre class=""><span style="padding-right: 0.1px;"><span class="cm-variable">UIApplicationDidChangeStatusBarOrientationNotification</span></span></pre>
                  <pre class=""><span style="padding-right: 0.1px;"><span class="cm-comment">// 通知事件数据字典里自定义数据的key</span></span></pre>
                  <pre class=""><span style="padding-right: 0.1px;"><span class="cm-variable">UIApplicationStatusBarOrientationUserInfoKey</span></span></pre>
                  <pre class=""><span style="padding-right: 0.1px;"><span class="cm-comment">// 旋转动画时长</span></span></pre>
                  <pre class=""><span style="padding-right: 0.1px;">[<span class="cm-variable">UIApplication</span> <span class="cm-variable">sharedApplication</span>].<span class="cm-variable">statusBarOrientationAnimationDuration</span></span></pre>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div style="position: absolute; height: 30px; width: 1px; top: 0px;"></div>
        <div class="CodeMirror-gutters" style="display: none; height: 220px;"></div>
      </div>
    </div>
    <p>因为iOS7和之后系统表现不一致，所以我们最好是自己监视通知，自己维护加到window的subview的状态。</p>
    <p>因为我们期望跟着系统旋转动画的时候一起处理好我们的subview，所以应该监视WillChange通知。</p>
    <p>WillChange通知发生的时候，statusBarOrientation会取得旋转前的方向，通知内的数据会是要旋转到的方向。</p>
    <p>DidChange通知发生的时候，statusBarOrientation会取得旋转后的方向，通知内的数据会是旋转前的方向。</p>
    <p>取得了将要旋转到的方向，对我们的subview做一个和系统旋转动画时长相同的动画就可以。需要注意的是，这个statusBarOrientationAnimationDuration是旋转90度用的时长，旋转180度时要x2（不过其实可以不太在意）。</p>
    <h4><a name='header-c379' class='md-header-anchor' id="header-c379"></a>关于WindowLevel</h4>
    <p>系统定义了三种WindowLevel，值其实都是CGFloat型的：</p>
    <pre class="md-fences md-end-block" lang="objective-c"> </pre>
    <div class="CodeMirror cm-s-inner CodeMirror-wrap">
      <div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"></div>
      <div class="CodeMirror-hscrollbar" style="left: 0px; min-height: 18px;">
        <div style="height: 100%; min-height: 1px; width: 0px;"></div>
      </div>
      <div class="CodeMirror-vscrollbar" style="min-width: 18px;">
        <div style="min-width: 1px; height: 0px;"></div>
      </div>
      <div class="CodeMirror-scrollbar-filler"></div>
      <div class="CodeMirror-gutter-filler"></div>
      <div class="CodeMirror-scroll" tabindex="-1">
        <div class="CodeMirror-sizer" style="margin-left: 0px; min-height: 0px;">
          <div style="position: relative; top: 0px;">
            <div class="CodeMirror-lines">
              <div style="position: relative; outline: none;">
                <div class="CodeMirror-measure">
                  <div style="width: 50px; height: 50px; overflow-x: scroll;"></div>
                </div>
                <div class="CodeMirror-measure"></div>
                <div style="position: relative; z-index: 1;"></div>
                <div class="CodeMirror-code" style="">
                  <div class="CodeMirror-activeline" style="position: relative;">
                    <div class="CodeMirror-activeline-background CodeMirror-linebackground"></div>
                    <pre class=""><span style="padding-right: 0.1px;"><span class="cm-comment">// 普通window的level，实际值是0</span></span></pre>
                  </div>
                  <pre class=""><span style="padding-right: 0.1px;"><span class="cm-variable">UIWindowLevel</span> <span class="cm-variable">UIWindowLevelNormal</span>;</span></pre>
                  <pre class=""><span style="padding-right: 0.1px;"><span class="cm-comment">// Alert弹窗window的level，实际值是2000</span></span></pre>
                  <pre class=""><span style="padding-right: 0.1px;"><span class="cm-variable">UIWindowLevel</span> <span class="cm-variable">UIWindowLevelAlert</span>;</span></pre>
                  <pre class=""><span style="padding-right: 0.1px;"><span class="cm-comment">// 状态栏window的level，实际值是1000</span></span></pre>
                  <pre class=""><span style="padding-right: 0.1px;"><span class="cm-variable">UIWindowLevel</span> <span class="cm-variable">UIWindowLevelStatusBa</span>;</span></pre>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div style="position: absolute; height: 30px; width: 1px; top: 0px;"></div>
        <div class="CodeMirror-gutters" style="display: none; height: 132px;"></div>
      </div>
    </div>
    <p>这三个我注释的默认值没变过，但是不知道以后会不会变，使用的时候还是应该要使用对应的常量定义。</p>
    <p>值得一提的是UIWindowLevelAlert，系统创建的alert window实际的level会有一定的偏差（<a href='https://stackoverflow.com/questions/15422898/how-to-show-a-uiwindow-over-the-keyboard-but-under-a-uialertview'>参照资料</a>，我也遇到过），需要比alert window层级高或者低的时候建议+50或者-50（因为键盘window的level是2100，折中）。</p>
    <h4><a name='header-c403' class='md-header-anchor' id="header-c403"></a>自定义window的其他注意点</h4>
    <p>userInteractionEnabled需要记得设置成NO，不然上层的window会截获各种触摸事件，App就点不动了。</p>
    <p>如果有多处代码需要同时管理userInteractionEnabled属性，最好写一个计数的manager来统一管理。</p>
    <p>另外很诡异的一点是，一定要给window设置一个空的rootViewController：</p>
    <pre class="md-fences md-end-block" lang="objective-c"> </pre>
    <div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="objective-c">
      <div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"></div>
      <div class="CodeMirror-hscrollbar" style="left: 0px; min-height: 18px;">
        <div style="height: 100%; min-height: 1px; width: 0px;"></div>
      </div>
      <div class="CodeMirror-vscrollbar" style="min-width: 18px;">
        <div style="min-width: 1px; height: 0px;"></div>
      </div>
      <div class="CodeMirror-scrollbar-filler"></div>
      <div class="CodeMirror-gutter-filler"></div>
      <div class="CodeMirror-scroll" tabindex="-1">
        <div class="CodeMirror-sizer" style="margin-left: 0px; min-height: 0px;">
          <div style="position: relative; top: 0px;">
            <div class="CodeMirror-lines">
              <div style="position: relative; outline: none;">
                <div class="CodeMirror-measure">
                  <div style="width: 50px; height: 50px; overflow-x: scroll;"></div>
                </div>
                <div class="CodeMirror-measure"></div>
                <div style="position: relative; z-index: 1;"></div>
                <div class="CodeMirror-code">
                  <div class="CodeMirror-activeline" style="position: relative;">
                    <div class="CodeMirror-activeline-background CodeMirror-linebackground"></div>
                    <pre><span style="padding-right: 0.1px;"><span class="cm-variable">window</span>.<span class="cm-variable">rootViewController</span> <span class="cm-operator">=</span> [<span class="cm-variable">UIViewController</span> <span class="cm-variable">new</span>];</span></pre>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div style="position: absolute; height: 30px; width: 1px; top: 0px;"></div>
        <div class="CodeMirror-gutters" style="display: none; height: 22px;"></div>
      </div>
    </div>
    <p>如果不设置这个rootViewController，系统在某些设备上无法正确的维护window的尺寸和旋转状态。</p>
    <p>自定义window是不需要makeKeyAndVisible的，只需要将hidden设为NO就会显示，设为YES就会消失。</p>
    <h4><a name='header-c439' class='md-header-anchor' id="header-c439"></a>诞生的开源库</h4>
    <p>实验完所有这些东西，诞生了开源库：<a href='https://github.com/HarrisonXi/TopmostView'>TopmostView</a></p>
    <p>如果你不想自己再处理一遍这些问题，可以直接使用这个库。</p>
    <p>有些最新的尝试我会放在<a href='https://github.com/HarrisonXi/TopmostView/tree/develop'>develop</a>分支，遇到问题也欢迎带着<a href='https://github.com/HarrisonXi/TopmostView/issues'>issue</a>来。</p>
    <hr>
    <p>© 2017 苹果梨　　<a href='/'>首页</a>　　<a href='/about.html'>关于</a>　　<a href='https://github.com/HarrisonXi'>GitHub</a>　　<a href='mailto:gpra8764@gmail.com'>Email</a></p>
  </div>
</body>
</html>
