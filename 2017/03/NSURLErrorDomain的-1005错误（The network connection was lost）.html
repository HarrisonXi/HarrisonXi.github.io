<!DOCTYPE html>
<html>
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Mac OS X version 5.4.0">
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width initial-scale=1'>
  <title>苹果梨的博客 - NSURLErrorDomain的-1005错误（The network connection was lost）</title>
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-110376743-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-110376743-1');
  </script>
  <link href='http://fonts.lug.ustc.edu.cn/css?family=Open+Sans:400italic,700italic,700,400&amp;subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  <link href='/css/github.css' rel='stylesheet' type='text/css'>
  <link href='/css/myblog.css' rel='stylesheet' type='text/css'>
</head>
<body class='typora-export'>
  <div id='write' class='is-mac'>
    <h1><a name='header-c7' class='md-header-anchor' id="header-c7"></a>NSURLErrorDomain的-1005错误</h1>
    <h4><a name='header-c8' class='md-header-anchor' id="header-c8"></a>（NSURLErrorNetworkConnectionLost，The network connection was lost）</h4>
    <table>
      <thead>
        <tr>
          <th>更新时间</th>
          <th>更新内容</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>2017-03-18</td>
          <td>发布</td>
        </tr>
      </tbody>
    </table>
    <h4><a name='header-c16' class='md-header-anchor' id="header-c16"></a>关于HTTP 1.1和HTTP长连接</h4>
    <p>HTTP 1.0中，默认进行的都是短连接。一个HTTP请求会产生一个TCP连接，请求结束后就会关闭这个TCP连接。而自HTTP 1.1开始，默认进行的都是<a href='https://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5'>长连接</a>。在一个HTTP请求结束之后，客户端和服务端之间的TCP连接并不会立即断开，而是按照约定的Keep-Alive时长维持一定时间的连接状态。这样在下一次HTTP请求发生时，如果TCP连接还存在就会复用之前的TCP连接，省去重新建立TCP连接的时间。</p>
    <h4><a name='header-c19' class='md-header-anchor' id="header-c19"></a>iOS的-1005错误</h4>
    <p>我们的团队是在使用SDWebImage的时候遇到这个问题的，经搜索发现早在iOS 8时代就有人在使用AFNetworking的时候遇到这个问题：<a href='http://stackoverflow.com/questions/25372318/error-domain-nsurlerrordomain-code-1005-the-network-connection-was-lost'>NSURLErrorDomain的-1005错误</a></p>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>Error Domain=NSURLErrorDomain Code=-1005 "The network connection was lost." </pre>
    <p>具体的原因参照<a href='http://stackoverflow.com/a/25996971/2562905'>这个回答</a>的描述：NSURLRequest的实现有问题，在维持长连接的时候维持时长超过了服务器约定的时长，在第二次HTTP请求准备复用TCP连接的时候实际上连接已经被服务器断开了。</p>
    <p>我没有去调研&amp;测试NSURLRequest的实现是不是真的有问题，倒是觉得移动设备的一些极端网络情况可能的确会面临这样的问题。</p>
    <p>那么接下来就是要解决这个问题。</p>
    <h4><a name='header-c29' class='md-header-anchor' id="header-c29"></a>由服务端解决这个问题</h4>
    <h5><a name='header-c30' class='md-header-anchor' id="header-c30"></a>1. 提高服务器Keep-Alive时长至30秒以上</h5>
    <p>我在简书上也看到有人将Keep-Alive时长设置成了60秒，对应问题可以解决。</p>
    <p>但是这个设置对于服务器是有风险的。延长Keep-Alive时长无疑会浪费服务器的性能，毕竟同时需要维持的连接数变多了。很多用户其实也不需要这么长时间的长连接。所以这个方案需要斟酌之后再确定要不要实行。</p>
    <h5><a name='header-c35' class='md-header-anchor' id="header-c35"></a>2. 针对iOS客户端禁用长连接</h5>
    <p>不同的服务器设置方法不一样，具体方法就不多说了。</p>
    <p>这个方案的风险在于，抛弃了长连接会对HTTP请求的速度产生些许影响。</p>
    <h4><a name='header-c40' class='md-header-anchor' id="header-c40"></a>由客户端解决这个问题</h4>
    <h5><a name='header-c41' class='md-header-anchor' id="header-c41"></a>1. 重新实现HTTP请求底层，降低客户端Keep-Alive时长</h5>
    <p>这是个大工程，我们需要写一个完备的底层，使客户端的Keep-Alive时长比服务端传回的时长短一些。这样的话就更低概率甚至不会出现服务端比客户端早断开TCP连接的情况。在出现长连接断开的情况下，底层也应该负责进行一次重试，再开一个新的TCP连接进行HTTP请求。</p>
    <h5><a name='header-c44' class='md-header-anchor' id="header-c44"></a>2. 由业务层或框架层重试HTTP请求</h5>
    <p>出现错误的时候重试一次HTTP请求就好。在框架或者业务代码里仍然用NSURLRequest实现请求，捕获到-1005错误的时候进行一次重试。虽然说总体用时会更长，但是正确的结果更加重要些。</p>
    <h4><a name='header-c47' class='md-header-anchor' id="header-c47"></a>SDWebImage里的问题</h4>
    <p>在SDWebImage中遇到此问题的现象：有些图片一旦请求失败一次就再也没法刷出来。</p>
    <p>归根结底在于SDWebImage维护了一个<strong>failedURLs</strong>列表，请求失败的图片URL都会被加入到这个表中。下次请求的时候如果没有带上SDWebImageRetryFailed选项，SDWebImage就会自动忽略这些URL直接返回错误。</p>
    <p>某些特殊的网络错误会被判定是网络连接问题，请求失败时SDWebImage不会将图片URL加入<strong>failedURLs</strong>列表。而这个特殊的网络错误列表里之前没有包含-1005错误，导致出现-1005错误后这些图片就再也不会被重加载。</p>
    <p>好在2个月前（2017-1-6）有人提交了对应的修改：<a href='https://github.com/rs/SDWebImage/commit/57502a9d1d3044a2c2f7969e5241619a697625fb'>add a network error situation</a>，我们的SDWebImage是太久没更新了才会遇到这个问题。</p>
    <h4><a name='header-c56' class='md-header-anchor' id="header-c56"></a>YYWebImage里的实现</h4>
    <p>参照<a href='https://github.com/ibireme/YYWebImage/blob/master/YYWebImage/YYWebImageOperation.m'>YYWebImageOperation</a>类的实现。</p>
    <p>和SDWebImage实现不同的是：</p>
    <ol start=''>
      <li>YYWebImage默认是不会记录<strong>URLInBlackList</strong>的，只有带上YYWebImageOptionIgnoreFailedURL选项，请求图片失败时才会把图片URL加入<strong>URLInBlackList</strong>。</li>
      <li>YYWebImage默认是会重试<strong>URLInBlackList</strong>的，必须带上YYWebImageOptionIgnoreFailedURL选项，才会忽略URLInBlackList中的图片URL。</li>
    </ol>
    <p>介于以上原因，实际上按照默认行为使用YYWebImage时如果加载图片失败，下一次加载还是会重试的，所以不会导致图片一直刷不出的严重问题。</p>
    <p>当然YYWebImage处理的网络连接问题列表里也没有包含-1005错误，所以我已经提了<a href='https://github.com/ibireme/YYWebImage/pull/172'>pull request</a>。</p>
    <h4><a name='header-c72' class='md-header-anchor' id="header-c72"></a>总结</h4>
    <p>对于大部分团队来说，应该还是用客户端方案2来处理比较方便。</p>
    <p>需要做的就是在客户端请求服务API和图片资源时，出现-1005错误就进行一次重试。</p>
    <p>当然如果使用了以上图片库，记得更新下最新版或者手动加上对-1005错误的处理。</p>
    <hr>
    <p>© 2017 苹果梨　　<a href='/'>首页</a>　　<a href='/about.html'>关于</a>　　<a href='https://github.com/HarrisonXi'>GitHub</a>　　<a href='mailto:gpra8764@gmail.com'>Email</a></p>
  </div>
</body>
</html>
