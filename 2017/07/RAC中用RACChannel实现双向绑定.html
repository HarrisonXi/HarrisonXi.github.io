<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> RAC中用RACChannel实现双向绑定 · 苹果梨的博客</title><meta name="description" content="RAC中用RACChannel实现双向绑定 - 苹果梨"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://blog.harrisonxi.com/atom.xml" title="苹果梨的博客"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about.html" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/links.html" target="_self" class="nav-list-link">友链</a></li><li class="nav-list-item"><a href="https://github.com/HarrisonXi" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">RAC中用RACChannel实现双向绑定</h1><div class="post-info">2017-07-27<a href="/categories/iOS" class="post-category">iOS</a></div><div class="post-content"><h1 id="尝试直接用RACSignal实现双向绑定"><a href="#尝试直接用RACSignal实现双向绑定" class="headerlink" title="尝试直接用RACSignal实现双向绑定"></a>尝试直接用RACSignal实现双向绑定</h1><p>在某些场景下，我们需要把两个数据相互绑定，A的改动影响B，B的改动也影响A。</p>
<p>为了表现上容易观察，我们先假设有一个同步两个文本框输入内容的需求。</p>
<a id="more"></a>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAC(<span class="keyword">self</span>.textFieldA, text) = <span class="keyword">self</span>.textFieldB.rac_textSignal;</span><br><span class="line">RAC(<span class="keyword">self</span>.textFieldB, text) = <span class="keyword">self</span>.textFieldA.rac_textSignal;</span><br></pre></td></tr></table></figure>

<p>实现两个文本框，用上面的代码相互绑定，然后观看效果：</p>
<p><img src="/2017/07/26-A.gif" alt="26-A"></p>
<p>可以看到所得到的效果和我们想要的是一致的。但是这只是一个比较凑巧的案例，因为UITextField的<code>rac_textSignal</code>监视的其实是UI事件：</p>
<p><img src="/2017/07/26-B.png" alt="26-B"></p>
<p>在UITextField的<code>text</code>属性改变时，不会触发<code>rac_textSignal</code>。所以在A-&gt;B的信号影响了B的<code>text</code>时，不会触发B-&gt;A的信号。</p>
<h1 id="对通常的数据用RACSignal实现双向绑定会出现的问题"><a href="#对通常的数据用RACSignal实现双向绑定会出现的问题" class="headerlink" title="对通常的数据用RACSignal实现双向绑定会出现的问题"></a>对通常的数据用RACSignal实现双向绑定会出现的问题</h1><p>而对于通常的数据来说进行双向绑定就会出错，代码和错误直接一图流甩出来先：</p>
<p><img src="/2017/07/26-C.png" alt="26-C"></p>
<p>看一眼错误的根源：</p>
<p><img src="/2017/07/26-D.png" alt="26-D"></p>
<p>可以看到这里出错的原因就是调用堆栈溢出了。因为双向绑定完成后，A的改动影响了B，然后B的改动又会影响A，形成了一个信号循环：</p>
<p><img src="/2017/07/26-F.png" alt="26-F"></p>
<p>打破这个循环的方法也很简单，在信号订阅的block体内进行数据改动时，想办法不发出信号：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">[RACObserve(<span class="keyword">self</span>, a) subscribeNext:^(<span class="built_in">NSString</span> *x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">self</span>-&gt;_b = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"A-&gt;B: %@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[RACObserve(<span class="keyword">self</span>, b) subscribeNext:^(<span class="built_in">NSString</span> *x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">self</span>-&gt;_a = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"B-&gt;A: %@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>在这里我们使用成员变量去修改A和B就可以了，完美搞定。</p>
<p>但是这不是万能的，存在很多缺陷：</p>
<ol>
<li>没办法使用<code>RAC(self, a) = RACObserve(self, b);</code>这样优雅的写法了。</li>
<li>访问不到内部成员变量的时候，没有办法这样写。</li>
<li>如果为了这个需求来暴露内部成员变量，也是很不明智的行为，会破坏ViewModel的稳定性和封装性。</li>
</ol>
<h1 id="RACChannel的出现"><a href="#RACChannel的出现" class="headerlink" title="RACChannel的出现"></a>RACChannel的出现</h1><p>在这个时候，RACChannel就随需要出现了。</p>
<h2 id="RACChannelTerminal简介"><a href="#RACChannelTerminal简介" class="headerlink" title="RACChannelTerminal简介"></a>RACChannelTerminal简介</h2><p>当然看RACChannel要先看RACChannelTerminal，RACChannelTerminal它是一个RACSignal同时也是一个RACSubscriber，就是说它能发出信号也能订阅信号。我们之后称呼它为终端，它在初始化的时候传入了两个值：</p>
<ol>
<li><code>values</code>：终端自己对应的RACReplaySubject（作为RACSignal使用）。外部订阅终端时订阅的实际上是<code>values</code>。</li>
<li><code>otherTerminal</code>：另一个终端对应的RACReplaySubject（作为RACSubscriber使用），终端在订阅外部信号后会把收到的信号都转发给<code>otherTerminal</code>。</li>
</ol>
<h2 id="RACReplaySubject简介"><a href="#RACReplaySubject简介" class="headerlink" title="RACReplaySubject简介"></a>RACReplaySubject简介</h2><p>RACReplaySubject是一种特殊的RACSubject，它可以向新的订阅者重新发送一遍之前所发过的信号。初始化RACReplaySubject的时候会要求设置一个<code>capacity</code>，默认值为NSUIntegerMax，RACReplaySubject会replay最多<code>capacity</code>个发过的<code>next</code>信号。值得注意的是，<code>completed</code>和<code>error</code>信号是始终会replay的，和<code>capacity</code>设置的大小无关。</p>
<h2 id="RACChannel代码解析"><a href="#RACChannel代码解析" class="headerlink" title="RACChannel代码解析"></a>RACChannel代码解析</h2><p>我们回过头来看RACChannel的完整代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RACChannel</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't want any starting value from the leadingSubject, but we do want</span></span><br><span class="line">    <span class="comment">// error and completion to be replayed.</span></span><br><span class="line">    RACReplaySubject *leadingSubject = [[RACReplaySubject replaySubjectWithCapacity:<span class="number">0</span>] setNameWithFormat:<span class="string">@"leadingSubject"</span>];</span><br><span class="line">    RACReplaySubject *followingSubject = [[RACReplaySubject replaySubjectWithCapacity:<span class="number">1</span>] setNameWithFormat:<span class="string">@"followingSubject"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Propagate errors and completion to everything.</span></span><br><span class="line">    [[leadingSubject ignoreValues] subscribe:followingSubject];</span><br><span class="line">    [[followingSubject ignoreValues] subscribe:leadingSubject];</span><br><span class="line"></span><br><span class="line">    _leadingTerminal = [[[RACChannelTerminal alloc] initWithValues:leadingSubject otherTerminal:followingSubject] setNameWithFormat:<span class="string">@"leadingTerminal"</span>];</span><br><span class="line">    _followingTerminal = [[[RACChannelTerminal alloc] initWithValues:followingSubject otherTerminal:leadingSubject] setNameWithFormat:<span class="string">@"followingTerminal"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>首先RACChannel创建了两个RACReplaySubject，这是内部的数据通信管道主要组件。</p>
<p>其中<code>followingSubject</code>的<code>capacity</code>为1，表示会replay最后一次的信号。因为<code>followingSubject</code>是供外部订阅用的，所以首次被订阅时需要给外部一个初始值。</p>
<p>然后这两个RACReplaySubject相互监视了对方的<code>completed</code>和<code>error</code>信号（<code>ignoreValues</code>用于排除<code>next</code>信号），这是为了保证两个Subject始终同步，不会其中一个已经终止了另一个还在工作。</p>
<p>最后创建了两个终端将这两个Subject相互绑定，终端所做的工作图示如下：</p>
<p><img src="/2017/07/27-A.png" alt="27-A"></p>
<p>总体看下来，RACChannel的设计思想上就是提供两个终端，每个终端各有一个输入口和一个输出口，一个终端负责和内部数据绑定，一个终端暴露出来供外部数据绑定。上图把外部订阅者和外部信号源分开来写，表示它们可能是不同的对象，当然它们也可以是相同的对象（如另一个RACChannel的终端）。一般来说封装好的供使用的RACChannel会将其中一个终端在内部处理好，暴露另一端供使用者进行输入和输出的绑定。</p>
<h2 id="RACChannel尚难直接使用"><a href="#RACChannel尚难直接使用" class="headerlink" title="RACChannel尚难直接使用"></a>RACChannel尚难直接使用</h2><p>这么看下来，是不是创建个RACChannel，把四个口绑定好就可以双向传输数据了？试一试：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACChannel *channel = [RACChannel new];</span><br><span class="line">RAC(<span class="keyword">self</span>, a) = channel.leadingTerminal;</span><br><span class="line">[RACObserve(<span class="keyword">self</span>, a) subscribe:channel.leadingTerminal];</span><br><span class="line">RAC(<span class="keyword">self</span>, b) = channel.followingTerminal;</span><br><span class="line">[RACObserve(<span class="keyword">self</span>, b) subscribe:channel.followingTerminal];</span><br></pre></td></tr></table></figure>

<p>然后，你会再次得到调用堆栈溢出的错误。😂</p>
<p>因为RACChannel只是实现了双向绑定的设计思想，并没有帮我们处理循环调用的问题。我们在使用RACChannel的时候一般是需要使用它的子类，或者自己设计好代码在某条信号通路上进行打断。</p>
<h1 id="RACKVOChannel"><a href="#RACKVOChannel" class="headerlink" title="RACKVOChannel"></a>RACKVOChannel</h1><p>看了那么多代码和原理，是时候晒一下简便正确的写法振奋人心了。想要实现A和B双向绑定，其实一句就可以：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACChannelTo(<span class="keyword">self</span>, a) = RACChannelTo(<span class="keyword">self</span>, b);</span><br></pre></td></tr></table></figure>

<p>这就是前文提到的在内部实现好循环调用终止条件的RACChannel了。</p>
<h2 id="RACChannelTo的展开"><a href="#RACChannelTo的展开" class="headerlink" title="RACChannelTo的展开"></a>RACChannelTo的展开</h2><p>我们把<code>RACChannelTo(self, a)</code>先展开来，看一下它到底做了什么：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RACKVOChannel alloc] initWithTarget:<span class="keyword">self</span> keyPath:<span class="string">@"a"</span> nilValue:<span class="literal">nil</span>][<span class="string">@"followingTerminal"</span>]</span><br></pre></td></tr></table></figure>

<p>所以说，上面实现双向绑定的语句展开来，实际上做了两件事：</p>
<ol>
<li>为A和B分别创建了<code>channelA</code>和<code>channelB</code>。</li>
<li>调用<code>channelA[@&quot;followingTerminal&quot;] = channelB[@&quot;followingTerminal&quot;]</code>。</li>
</ol>
<p>如果你对宏定义展开的细节感兴趣，我觉得Sunny大大的<a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="noopener">这篇博客</a>可以帮到你。</p>
<h2 id="RACKVOChannel如何实现双向绑定"><a href="#RACKVOChannel如何实现双向绑定" class="headerlink" title="RACKVOChannel如何实现双向绑定"></a>RACKVOChannel如何实现双向绑定</h2><p>我们看一下这段代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RACKVOChannel</span> (<span class="title">RACChannelTo</span>)</span></span><br><span class="line"></span><br><span class="line">- (RACChannelTerminal *)objectForKeyedSubscript:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(key != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    RACChannelTerminal *terminal = [<span class="keyword">self</span> valueForKey:key];</span><br><span class="line">    <span class="built_in">NSCAssert</span>([terminal isKindOfClass:RACChannelTerminal.class], <span class="string">@"Key \"%@\" does not identify a channel terminal"</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> terminal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(RACChannelTerminal *)otherTerminal forKeyedSubscript:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(otherTerminal != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    RACChannelTerminal *selfTerminal = [<span class="keyword">self</span> objectForKeyedSubscript:key];</span><br><span class="line">    [otherTerminal subscribe:selfTerminal];</span><br><span class="line">    [[selfTerminal skip:<span class="number">1</span>] subscribe:otherTerminal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><code>objectForKeyedSubscript:</code>提供了通过键<code>@“followingTerminal”</code>读取终端的能力，<code>setObject:forKeyedSubscript:</code>提供了通过键<code>@“followingTerminal”</code>设定和绑定终端的能力。</p>
<p>绑定的操作其实就是将两个<code>followingTerminal</code>相互订阅。注意因为两端数据是同步的，所以在正向订阅后两端的值应该一样了，所以在反向绑定的时候就可以<code>skip:1</code>来节约点性能了。</p>
<h2 id="RACKVOChannel在哪里打断了信号通道的循环调用"><a href="#RACKVOChannel在哪里打断了信号通道的循环调用" class="headerlink" title="RACKVOChannel在哪里打断了信号通道的循环调用"></a>RACKVOChannel在哪里打断了信号通道的循环调用</h2><p>可以看到这段代码首先创建了一个RACKVOChannel，RACKVOChannel里主要做的两件事就是<code>leadingTerminal</code>的<code>sendNext</code>和<code>leadingTerminal</code>和<code>subscribeNext</code>，这个从前面一点点读下来的读者应该都能明白，是将目标的指定属性和RACKVOChannel的<code>leadingTerminal</code>做好绑定。</p>
<p>我们主要关注的是，RACKVOChannel在哪里打断了信号通道的循环调用。先看<code>subscribeNext</code>段里这一部分：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the ignoreNextUpdate flag before setting the value so this channel</span></span><br><span class="line"><span class="comment">// ignores the value in the subsequent -didChangeValueForKey: callback.</span></span><br><span class="line">[<span class="keyword">self</span> createCurrentThreadData];</span><br><span class="line"><span class="keyword">self</span>.currentThreadData.ignoreNextUpdate = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>

<p>注释写得比较清楚，这个<code>ignoreNextUpdate</code>使得下一次的值修改被忽略。具体的忽略代码在<code>sendNext</code>段：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the change wasn't triggered by deallocation, only affects the last</span></span><br><span class="line"><span class="comment">// path component, and ignoreNextUpdate is set, then it was triggered by</span></span><br><span class="line"><span class="comment">// this channel and should not be forwarded.</span></span><br><span class="line"><span class="keyword">if</span> (!causedByDealloc &amp;&amp; affectedOnlyLastComponent &amp;&amp; <span class="keyword">self</span>.currentThreadData.ignoreNextUpdate) &#123;</span><br><span class="line">    [<span class="keyword">self</span> destroyCurrentThreadData];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ignoreNextUpdate</code>为YES的时候，这里就会return出去，不会触发<code>sendNext</code>操作。</p>
<p>用图片标记的直观点，就是如果是在<code>leadingTerminal</code>的<code>subscribeNext</code>里修改了目标的属性值，通路会在此打断，不会重复的再把属性址改变的信号<code>sendNext</code>出去：</p>
<p><img src="/2017/07/27-B.png" alt="27-B"></p>
<h2 id="RACChannelTo总结"><a href="#RACChannelTo总结" class="headerlink" title="RACChannelTo总结"></a>RACChannelTo总结</h2><p>总之进行通常数据的双向绑定，RACChannelTo基本就是无敌的，几乎可以完成绝大部分需求了。</p>
<h1 id="其他常见的RACChannel相关的类扩展"><a href="#其他常见的RACChannel相关的类扩展" class="headerlink" title="其他常见的RACChannel相关的类扩展"></a>其他常见的RACChannel相关的类扩展</h1><p>RAC库对常用的组件都进行了扩展方便我们使用，下面举几个例子。</p>
<h2 id="NSUserDefaults-RACSupport"><a href="#NSUserDefaults-RACSupport" class="headerlink" title="NSUserDefaults (RACSupport)"></a>NSUserDefaults (RACSupport)</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACChannelTerminal *)rac_channelTerminalForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>

<p>为指定的<code>key</code>创建一个双向绑定用的RACChannel，在内部和RACKVOChannel做了同样的切断循环操作。注意这里返回的是<code>followingTerminal</code>。</p>
<h2 id="UITextField-RACSignalSupport"><a href="#UITextField-RACSignalSupport" class="headerlink" title="UITextField (RACSignalSupport)"></a>UITextField (RACSignalSupport)</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACChannelTerminal&lt;<span class="built_in">NSString</span> *&gt; *)rac_newTextChannel;</span><br></pre></td></tr></table></figure>

<p>为文本的变更创建一个双向绑定用的RACChannel，因为本文最前面提到的原因，文本变更信号是从UI事件触发的，接受新的文本是设置到<code>text</code>属性的，所以两者相互独立本来就不会循环调用。另外注意这里返回的是<code>leadingTerminal</code>，使用上要特别注意的是初次绑定的时候不会触发一次初始化信号，这样正好可以方便配合别的<code>followingTerminal</code>使用而不需要进行<code>skip:1</code>。</p>
<p>其它的UI控件的RACChannel扩展和UITextField都类似。</p>
<h2 id="合并使用的示例"><a href="#合并使用的示例" class="headerlink" title="合并使用的示例"></a>合并使用的示例</h2><p>这里是一个和ViewModel进行绑定的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果仅需要单向绑定，使用rac_textSignal</span></span><br><span class="line"><span class="comment">// RAC(self.viewModel, username) = self.usernameTextField.rac_textSignal;</span></span><br><span class="line"><span class="comment">// 如果需要双向绑定，则使用rac_newTextChannel</span></span><br><span class="line">RACChannelTo(<span class="keyword">self</span>.viewModel, username) = <span class="keyword">self</span>.usernameTextField.rac_newTextChannel;</span><br></pre></td></tr></table></figure>

<p>需要注意的一点是，每一次调用<code>rac_newTextChannel</code>都是创建一个新的RACChannel，如果需要进行多次重复使用，请自行把获得的RACChannelTerminal保存下来。</p>
<p>如果是NSUserDefaults和UITextField双向绑定，可以手动写一下订阅：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACChannelTerminal *userDefaultsTerminal = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] rac_channelTerminalForKey:<span class="string">@"username"</span>];</span><br><span class="line">RACChannelTerminal *textfieldTerminal = <span class="keyword">self</span>.usernameTextField.rac_newTextChannel;</span><br><span class="line">[textfieldTerminal subscribe:userDefaultsTerminal];</span><br><span class="line">[userDefaultsTerminal subscribe:textfieldTerminal];</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不得不说RAC的作者大神们伟大之极，当之无愧的ObjC新纪元开创者。RACChannel思路简单但是实现起来真的不简单，阅读代码慢慢理解RAC的精华实在是一种愉悦～</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/09/RAC%E4%B8%AD%E7%94%A8RACCommand%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4.html" class="prev">上一篇</a><a href="/2017/07/iOS%E4%BD%BF%E7%94%A8RAC%E5%AE%9E%E7%8E%B0MVVM%E7%9A%84%E6%AD%A3%E7%BB%8F%E5%A7%BF%E5%8A%BF.html" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'ping-guo-li-de-bo-ke';
var disqus_identifier = '2017/07/RAC中用RACChannel实现双向绑定.html';
var disqus_title = 'RAC中用RACChannel实现双向绑定';
var disqus_url = 'https://blog.harrisonxi.com/2017/07/RAC中用RACChannel实现双向绑定.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//ping-guo-li-de-bo-ke.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2024 <a href="https://blog.harrisonxi.com">苹果梨</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-110376743-1",'auto');ga('send','pageview');</script></body></html>