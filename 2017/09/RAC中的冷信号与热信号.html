<!DOCTYPE html>
<html>
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Mac OS X version 5.4.0">
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width initial-scale=1'>
  <title>苹果梨的博客 - RAC中的冷信号与热信号</title>
  <link href='http://fonts.lug.ustc.edu.cn/css?family=Open+Sans:400italic,700italic,700,400&amp;subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  <link href='/css/github.css' rel='stylesheet' type='text/css'>
  <link href='/css/myblog.css' rel='stylesheet' type='text/css'>
</head>
<body class='typora-export'>
  <div id='write' class='is-mac'>
    <h1><a name='header-n2' class='md-header-anchor' id="header-n2"></a>RAC中的冷信号与热信号</h1>
    <table>
      <thead>
        <tr>
          <th>更新时间</th>
          <th>更新内容</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>2017-09-21</td>
          <td>发布</td>
        </tr>
      </tbody>
    </table>
    <h3><a name='header-n10' class='md-header-anchor' id="header-n10"></a>前言</h3>
    <p>本文主旨是浅显易懂的讲解下冷热信号的区别和常见的使用误区，所以篇幅所限不会介绍些内部细节。</p>
    <p>如果想要了解的更深入，可以参照William Zang的博文：<a href='http://williamzang.com/blog/2015/08/18/talk-about-reactivecocoas-cold-signal-and-hot-signal/'>细说ReactiveCocoa的冷信号与热信号</a>。</p>
    <p>文中部分内容参考RAC 4.x的文档：<a href='https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v4.2.2/Documentation/DesignGuidelines.md#the-signal-contract'>设计指南</a>、<a href='https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v4.2.2/Documentation/FrameworkOverview.md'>框架概览</a>，但是文章本身是介绍ObjC的RAC 2.5。</p>
    <p>另外和前一篇博文一样，我称呼一组信号叫做<strong>信号流</strong>，单次发送的信号值为<strong>信号</strong>。</p>
    <h3><a name='header-n37' class='md-header-anchor' id="header-n37"></a>热信号流</h3>
    <p>热信号流在RAC 3.x以后为Signal，在RAC 2.5中对应RACSubject。</p>
    <h5><a name='header-n122' class='md-header-anchor' id="header-n122"></a>特征</h5>
    <p>所谓热信号流是用来观察一组随时间流逝的事件用的。一般来说它被用作观察执行中（in progress）事件的进度或流程，例如下载事件的进度和流程。</p>
    <p>热信号流有以下特征：</p>
    <ol>
      <li>随信号发出者自己的进度发送信号，创建后即开始工作。</li>
      <li>新增观察者对信号流不产生任何<a href='https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8'>副作用</a>，无论有没有观察者这个信号流都做相同的工作。
      </li>
      <li>所有观察者都会在同样的时间收到同样的信号。</li>
    </ol>
    <h5><a name='header-n116' class='md-header-anchor' id="header-n116"></a>例子</h5>
    <p>举个例子，蒸包子大师傅一天的工作就可以成为一个热信号流，而围观大师傅蒸包子的人就是观察者：</p>
    <ol>
      <li>每半小时出笼一次包子，算作发送一次信号。大师傅兢兢业业，早上上班后就开始一直蒸包子。</li>
      <li>有人来围观大师傅蒸包子对大师傅不产生影响，无论有多少人围观大师傅，大师傅都是半小时出笼一次。</li>
      <li>每隔半小时，正在围观的人都能同时看到大师傅出笼一次包子。错过的人就看不到这次的出笼事件。</li>
    </ol>
    <p>可以说，这里的围观者更关注的是大师傅什么时候出笼包子这类事件。</p>
    <h5><a name='header-n129' class='md-header-anchor' id="header-n129"></a>代码</h5>
    <p>注意我们先在RACSubject.m里加上一段NSLog来记录发出的事件：</p>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>- (void)sendNext:(id)value {
        NSLog(@"RACSubject sendNext: %@", value);
        ...
}</pre>
    <p>然后写代码模仿上面的例子：</p>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>NSLog(@"create RACSubject");

RACSubject *subject = [RACSubject subject];
[subject sendNext:@"大师傅上班"];
[[RACScheduler mainThreadScheduler] afterDelay:1.0 schedule:^{
    [subject sendNext:@"第一次出笼"];
}];
[[RACScheduler mainThreadScheduler] afterDelay:2.0 schedule:^{
    [subject sendNext:@"第二次出笼"];
}];

[[RACScheduler mainThreadScheduler] afterDelay:0.5 schedule:^{
    NSLog(@"路人甲开始围观");
    [subject subscribeNext:^(NSString *msg) {
        NSLog(@"路人甲看到%@", msg);
    }];
}];

[[RACScheduler mainThreadScheduler] afterDelay:1.5 schedule:^{
    NSLog(@"路人乙开始围观");
    [subject subscribeNext:^(NSString *msg) {
        NSLog(@"路人乙看到%@", msg);
    }];
}];</pre>
    <p>观察日志：</p>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>2017-09-21 15:26:52.657 MvvmDemo[1246:146676] create RACSubject
2017-09-21 15:26:52.658 MvvmDemo[1246:146676] RACSubject sendNext: 大师傅上班
2017-09-21 15:26:53.203 MvvmDemo[1246:146676] 路人甲开始围观
2017-09-21 15:26:53.658 MvvmDemo[1246:146676] RACSubject sendNext: 第一次出笼
2017-09-21 15:26:53.659 MvvmDemo[1246:146676] 路人甲看到第一次出笼
2017-09-21 15:26:54.308 MvvmDemo[1246:146676] 路人乙开始围观
2017-09-21 15:26:54.856 MvvmDemo[1246:146676] RACSubject sendNext: 第二次出笼
2017-09-21 15:26:54.856 MvvmDemo[1246:146676] 路人甲看到第二次出笼
2017-09-21 15:26:54.857 MvvmDemo[1246:146676] 路人乙看到第二次出笼
</pre>
    <p>可以看到这完美的诠释了以上热信号流的各种特征。</p>
    <h3><a name='header-n212' class='md-header-anchor' id="header-n212"></a>冷信号流</h3>
    <p>冷信号流在RAC 3.x以后叫做Signal Producers，在RAC 2.5中对应RACSignal。</p>
    <p>注意RACSubject是RACSignal的一个子类，这也是RAC中大家常搞不清冷热信号流的一个重要原因。😂</p>
    <h5><a name='header-n229' class='md-header-anchor' id="header-n229"></a>特征</h5>
    <p>所谓冷信号流是创建一组信号和处理副作用的。它的主要作用是处理一组完整的操作或任务，供用户观察事件<strong>从开始到结束</strong>的整个流程和事件的<strong>结果</strong>。例如处理一整段网络请求相关操作，供用户观察请求的结果是什么。</p>
    <p>冷信号流有以下特征：</p>
    <ol>
      <li>创建时并不立刻开始工作，在被订阅的时候才开始工作。就是说订阅操作本身会对信号流产生作用。</li>
      <li>每个新增的订阅者收到的可能都是不同的，分别独立的信号流。这些信号流的结果也可能不同，因为冷信号流可能包含一些<a href='https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8'>副作用</a>。
      </li>
    </ol>
    <h5><a name='header-n274' class='md-header-anchor' id="header-n274"></a>例子</h5>
    <p>举个例子，包子店收银员卖出包子的过程就可以作为一个冷信号流，而每个买包子的顾客就是一个订阅者：</p>
    <ol>
      <li>收银员上班的时候不是立刻就有工作，在一个新的顾客来的时候才会进行卖包子的工作。</li>
      <li>每个顾客买到的包子都是不同的包子（即使馅一样，也是不同的实例）。而因为还有找不开钱，包子卖完了等各种副作用存在，有可能顾客还会买不到包子。</li>
    </ol>
    <h5><a name='header-n299' class='md-header-anchor' id="header-n299"></a>代码</h5>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>NSLog(@"create RACSignal");

static NSInteger count = 2;
RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    if (count &gt; 0) {
        [subscriber sendNext:@"给收银员钱"];
        [subscriber sendNext:@"买到包子"];
    } else {
        [subscriber sendNext:@"没买到包子"];
    }
    count--;
    [subscriber sendCompleted];
    return nil;
}];

[[RACScheduler mainThreadScheduler] afterDelay:1.0 schedule:^{
    [signal subscribeNext:^(NSString *msg) {
        NSLog(@"顾客甲%@", msg);
    }];
}];

[[RACScheduler mainThreadScheduler] afterDelay:2.0 schedule:^{
    [signal subscribeNext:^(NSString *msg) {
        NSLog(@"顾客乙%@", msg);
    }];
}];

[[RACScheduler mainThreadScheduler] afterDelay:3.0 schedule:^{
    [signal subscribeNext:^(NSString *msg) {
        NSLog(@"顾客丙%@", msg);
    }];
}];</pre>
    <p>注意，这里我们用<code>count</code>模拟了一个剩余包子数量的外部值作为<a href='https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8'>副作用</a>。但是这里没有做多线程保护，各位自己写代码的时候一定要记得做好对应的多线程保护。</p>
    <p>另外要加个NSLog，RACSignal发送信号其实最终是在RACPassthroughSubscriber.m里做的：</p>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>- (void)sendNext:(id)value {
        ...
        NSLog(@"RACSignal sendNext: %@", value);
        [self.innerSubscriber sendNext:value];
}</pre>
    <p>观察日志：</p>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>2017-09-21 17:09:06.349 MvvmDemo[1494:203071] create RACSignal
2017-09-21 17:09:07.351 MvvmDemo[1494:203071] RACSignal sendNext: 给收银员钱
2017-09-21 17:09:07.351 MvvmDemo[1494:203071] 顾客甲给收银员钱
2017-09-21 17:09:07.351 MvvmDemo[1494:203071] RACSignal sendNext: 买到包子
2017-09-21 17:09:07.351 MvvmDemo[1494:203071] 顾客甲买到包子
2017-09-21 17:09:08.350 MvvmDemo[1494:203071] RACSignal sendNext: 给收银员钱
2017-09-21 17:09:08.351 MvvmDemo[1494:203071] 顾客乙给收银员钱
2017-09-21 17:09:08.351 MvvmDemo[1494:203071] RACSignal sendNext: 买到包子
2017-09-21 17:09:08.351 MvvmDemo[1494:203071] 顾客乙买到包子
2017-09-21 17:09:09.648 MvvmDemo[1494:203071] RACSignal sendNext: 没买到包子
2017-09-21 17:09:09.648 MvvmDemo[1494:203071] 顾客丙没买到包子</pre>
    <p>可以看到一开始创建RACSignal的时候没有触发买包子流程，每有一个新的顾客来就会触发一个新的流程，流程也可能走向不同的结果。</p>
    <h3><a name='header-n386' class='md-header-anchor' id="header-n386"></a>误用的隐患</h3>
    <h5><a name='header-n387' class='md-header-anchor' id="header-n387"></a>冷信号流容易导致的问题</h5>
    <p>冷信号流是用于一对一环境的，为每个订阅者都重新执行一次独立的信号流。因此，冷信号流可能无意中被订阅很多次，重复运行很多次。看下面的代码：</p>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    NSLog(@"触发一次信号流");
    [subscriber sendCompleted];
    return nil;
}];

[[signal flatten] subscribeNext:^(id  _Nullable x) { }];
[[signal map:^id _Nullable(id  _Nullable value) {
    return nil;
}] subscribeNext:^(id  _Nullable x) { }];</pre>
    <p>这例子里的RACSignal的<code>flatten</code>和<code>map:</code>等方法其实也是通过订阅原信号流进行转换后再输出的，所以这里是会打印出两次『触发一次信号流』的。这种情况的增多，就更容易导致冷信号流被订阅次数增加。</p>
    <p>在这种前提下，我们就要注意以下情况下不能滥用冷信号流：</p>
    <ol>
      <li>信号体内有耗时的运算逻辑，如多次运行会造成性能问题。</li>
      <li>信号体内逻辑实际上不期望多次运行，如多次运行会出错。</li>
    </ol>
    <p>这时候我们可以用热信号流替代冷信号流，或者将冷信号流通过<code>publish</code>或者<code>multicast:</code>转换成RACMulticastConnection后进行热信号流式的一对多转发。这细节就不在此展开了，只给个示例：</p>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    NSLog(@"触发一次信号流");
    [subscriber sendCompleted];
    return nil;
}] publish];

[[connection.signal flatten] subscribeNext:^(id  _Nullable x) { }];
[[connection.signal map:^id _Nullable(id  _Nullable value) {
    return nil;
}] subscribeNext:^(id  _Nullable x) { }];

[connection connect];</pre>
    <h5><a name='header-n473' class='md-header-anchor' id="header-n473"></a>热信号流容易导致的问题</h5>
    <p>热信号流的问题就在于后订阅的订阅者可能丢失之前的某些信号，如果确实需要之前的某些信号时，可以使用RACBehaviorSubject或RACReplaySubject来完成。当然要注意的是，使用这两个类的时候，就只能关注信号的值而不能关心信号发生的时间了，因为时间在replay过程中已经被破坏了。</p>
    <h3><a name='header-n500' class='md-header-anchor' id="header-n500"></a>总结</h3>
    <p>总结起来，热信号流就像直播视频，冷信号流就像点播视频。正确的使用它们，是用好RAC的基础。</p>
    <p>大家加油，有问题的欢迎共同讨论哦。</p>
    <hr>
    <p>© 2017 苹果梨　　<a href='/'>首页</a>　　<a href='/about.html'>关于</a>　　<a href='https://github.com/HarrisonXi'>GitHub</a>　　<a href='mailto:gpra8764@gmail.com'>Email</a></p>
  </div>
</body>
</html>
